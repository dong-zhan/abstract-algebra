# import zd
# import abs_alg.abs_alg as aa
#
# import importlib
# importlib.reload(aa)

# kerl-pyaa.pdf
# Lect2-04web.pdf
# E:\3d techs\math\Abstract Algebra\Finite Group -- from Wolfram MathWorld.pdf

def rrr():
	importlib.reload(aa)
	
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import util.arr as arr
import util.tools as tools

import math_zd.number as number
from math_zd import modular


# if np,pd,plt is needed for console, copy imp() function to console, then run imp() in console  --> plot.imp() doesn't work.
def imp():
	global np, pd, plt, arr, tools
	import numpy as np
	import pandas as pd
	import matplotlib.pyplot as plt
	
	import util.arr as arr
	import util.tools as tools

def replace_readme_MD():
	tools.replace_line_break_with_br('F:/Python/zd/abs_alg/README.txt', 'F:/Python/zd/abs_alg/README.md')

def find_identity(X, binary_operation):
	"""
	X is a set
	find_identity([0, 1, 2], lambda x,y : (x+y) % 3)
	find_identity([0, 1, 2], lambda x,y : (x*y) % 3)
	"""
	for idd in X:
		isIdentity = True
		for x in X:
			if binary_operation(idd, x) != x:
				isIdentity = False
				break
		if isIdentity:
			return idd
	return None
	
def generate_left_coset(a, H, binary_operation):
	"""
	Let G be a group and H a subgroup, let a∈G. the set aH = {ah: h∈H} is a left coset of H.
	"""
	X = arr.array1(len(H))
	for ix, xi in enumerate(H):
		X[ix] = binary_operation(a, xi)
	return X

def generate_right_coset(H, a, binary_operation):
	"""
	Let G be a group and H a subgroup, let a∈G. the set Ha = {ha: h∈H} is a right coset of H.
	"""
	X = arr.array1(len(H))
	for ix, xi in enumerate(H):
		X[ix] = binary_operation(xi, a)
	return X
	
def subgroup_orders_generated_by_an_element(X):
	"""
	theorem (Lagrange Light)
	the order of a subgroup generated by an element is a divisor of the order of the group
	because <x> = {1, a, a², a³, ...,aᵏ⁻¹}		-- k terms
	"""
	return number.find_all_divisors(len(X))
	
	
def find_inverse(x, X, e, binary_operation):
	"""
	x is an element in set X
	X is a set
	e is identity
	find_inverse(1, [0, 1, 2], 0, lambda x,y : (x+y) % 3)
	"""
	for xi in X:
		if e == binary_operation(x, xi):
			return xi
	return None
	
def find_all_inverses(X, e, binary_operation):
	"""
	see test_find_all_inverses()
	"""
	IX = arr.array1(len(X))
	for ix, x in enumerate(X):
		inv = find_inverse(x, X, e, binary_operation)
		IX[ix] = inv
		#tools.printf("%d -> %d\n", x, inv)
		#if inv != None:
			#print(x)
	return IX
	

def has_Latin_Square_Property(X):
	"""
	every entry in column is different, and every entry in row is different
	"""
	return not arr.hasDuplicatesInRowsAndCols(X)
	
def count_inverse(X, e, binary_operation):
	"""
	X is a set, e is identity
	count_inverse([0, 1, 2, 3], 0, lambda x,y : (x+y)%4)
	"""
	IX = arr.array1(len(X))
	for i, a in enumerate(X):
		IX[i] = 0
		for b in X:
			ab = binary_operation(a, b)
			ba = binary_operation(b, a)
			if ab == e and ba == e:
				#print(a, b, ab, ba, e)
				IX[i] = IX[i]+1
	return IX
	
# TODO: vectorization
def is_associative(X, binary_operation):
	"""
	X is a set
	is_associative([2, 3, 4], lambda x,y : x-y)
	is_associative([2, 3, 4], lambda x,y : x+y)
	"""
	for a in X:
		for b in X:
			for c in X:
				ab = binary_operation(a, b)
				d1 = binary_operation(ab, c)
				bc = binary_operation(b, c)
				d2 = binary_operation(a, bc)
				if d1 != d2:
					#tools.printf("a=%d,b=%d,c=%d, ab=%d, d1=%d, bc=%d, d2=%d\n", a, b, c, ab, d1, bc, d2)
					return False
	return True
	
def is_closed(X, binary_operation):
	"""
	X is a set
	is_closed([0, 1, 2, 3, 4, 5], lambda x,y : (x+y) % 6)
	"""
	for a in X:
		for b in X:
			ab = binary_operation(a, b)
			if not ab in X:
				return False
	return True
	
def generate_additive_mod_N(N):
	"""
	The Additive Group of Integers Modulo n is the group with domain {0,1,2,…,n−1} and with the operation of mod n addition. It is denoted as Zn.
	"""
	return np.arange(0,N,1).tolist()
	
def generate_multipicative_mod_N(N):
	"""
	0 is not in the multiplicative group, since it is not invertible.
	"""
	return np.arange(1,N,1).tolist()

def generate_cyclic_mod_N(a, N):
	return modular.modular_pow_no_repeat(a, N)
	
def print_mod_group_info(X, binary_operation, N):
	T = generate_Cayley_table(X, binary_operation)
	T = np.array(T)
	
	tools.printf("Mod: %d\nSet: ", N)
	print(X)
	
	print("Cayley table")
	
	PT = generate_printable_Cayley_table(T, X)
	print_Cayley_table(PT)
	
	ia = is_associative(X, binary_operation)
	tools.printf("is_associative = %s\n", ia)
	
	identity = find_identity(X, binary_operation)
	#tools.printf("identity = %s\n", str(identity))
	
	INV = count_inverse(X, identity, binary_operation)
	cols = len(X)
	uniqueIdentity = True
	cnt = INV.count(1)
	if cnt != cols:
		uniqueIdentity = False
	
	tools.printf("unique identity: (%s) %s\n", identity, uniqueIdentity)	
	
	tools.printf("is_closed: %s\n", is_closed(X, binary_operation))
	
	tools.printf("Latin square property: %s\n", has_Latin_Square_Property(T.tolist()))	
	
def generate_Cayley_table(X, binary_operation):
	"""
	X is a set
	generate_Cayley_table([0, 1, 2, 3], lambda x,y : (x+y) % 4)
	generate_Cayley_table([1, 3, 7, 9], lambda x,y : (x*y) % 10)
	"""
	rows = len(X)
	cols = rows
	N = cols
	T = arr.array2(rows, cols)
	
	for irow, row in enumerate(X):
		for icol, col in enumerate(X):
			#print(irow, icol, row, col, binary_operation(row, col))
			T[irow][icol] = binary_operation(row, col)		
			
	return T
	
def generate_printable_Cayley_table(T, X):
	"""
	T is Cayley table
	X is a set
	add first row and first column into table, the top left should be the binary operation.
	"""
	rows = len(T) + 1
	cols = len(T[0]) + 1
	PT = arr.array2(rows, cols)
	
	for irow, row in enumerate(T):
		for icol, col in enumerate(T):
			PT[irow+1][icol+1] = T[irow][icol]	
			
	for i, ix in enumerate(T):
		PT[0][i+1] = X[i]
		PT[i+1][0] = X[i]
	
	#PT[0][0] = 0
	return PT
			
def print_Cayley_table(T, delimitor = ' '):
	"""
	T is printable Cayley table (Cayley table dimension extended by 1 for extra first row and first column)
	"""
	rows = len(T) + 1
	cols = len(T[0]) + 1
	
	for irow, row in enumerate(T):
		for icol, col in enumerate(T):
			t = T[irow][icol]
			if irow == 0 and icol == 0:
				tools.printf("X%c", delimitor)
			else:
				tools.printf("%d%c", t, delimitor)
		tools.printf("\n")
			
	
def Z(N):
	"""
	The Additive Group of Integers Modulo n is the group with domain  {0,1,2,…,n−1}  and with the operation of mod n addition. It is denoted as  Zn.
	Z/nZ is a standard notation for the additive cyclic group with n elements.
	binary_operation = lambda x,y : (x+y) % N
	"""
	return np.arange(0,N,1)
	
def U(N):
	"""
	The Multiplicative Group of Integers Modulo n is the group with domain  {k∈Z|1≤k≤n−1 and gcd(n,k)=1} and with the operation of mod n multiplication. It is denoted as Un.
	binary_operation = lambda x,y : (x*y) % N
	"""
	X = []
	for x in np.arange(1,N,1):
		if number.gcd(x, N) == 1:
			X.append(x)
	return X
	
def C(g, N):
	"""
	The “same” group can be written using multiplicative notation this way: Z7 = {1, a, a², a³, a⁴, a⁵, a⁶}.
	binary_operation = lambda x,y : (x*y) % N
	"""
	return modular.modular_pow_no_repeat(g, N)
	
def order_of_element(g, G, e, binary_operation):
	"""
	The order of an element g of a group G is the smallest positive integer n:gⁿ=e
	there is a formula using gcd
	"""
	if g == e:
		return 1
		
	order = 2
	while True:
		g1 = g
		for i in range(order-1):
			g1 = binary_operation(g1, g)
			if g1 == e:
				return order
		#tools.printf("%d·%d = %d\n", order, g, g1)
		order = order + 1


def subgroup_cyclic(g, binary_operation):
	"""
	A cyclic group is a group which is equal to one of its cyclic subgroups: G = <g> for some element g, called a generator of G. For a finite cyclic group G of order n we have G = {e, g, g², ... , g^n−1}, where e is the identity element and g^i = g^j whenever i ≡ j (mod n); in particular g^n = g^0 = e, and g^−1 = g^n−1.
	binary_operation can be addition or multiplication
	"""
	X = [g]
	g1 = g
	while True:
		g1 = binary_operation(g1, g)
		if g1 == g:
			return X
		X.append(g1)
		
		
	
	
def test_Carley_table_pow(b, m, N):
	"""
	b: base
	N: modulus
	m: count
	"""
	binary_operation = lambda x,y : (x*y) % N
	X = modular.modular_pow(b, N, m)
	print(X)
	X = generate_Cayley_table(X, binary_operation)
	X = np.array(X)
	print(X)
	
def test_find_all_inverses(b, N):
	binary_operation = lambda x,y : (x*y) % N
	X = modular.modular_pow_no_repeat(b, N)
	identity = find_identity(X, binary_operation)
	IX = find_all_inverses(X, identity, binary_operation)	
	return X, IX


def test_cyclic(a, N):
	isCoPrime = number.coprime2(a, N)
	tools.printf("a=%d and N=%d are coprime: %s\n", a, N, isCoPrime)
	tools.printf("so, a=%d has modular multiplicative inverse: %s\n", a, isCoPrime)

	tools.printf("cyclic group <%d> ", a)
	binary_operation = lambda x,y : (x*y) % N
	
	X = generate_cyclic_mod_N(a, N)
	
	print_mod_group_info(X, binary_operation, N)
	
def test_U(N):
	tools.printf("Multiplicative Group of Integers Modulo %d (U%d)\n", N, N)

	binary_operation = lambda x,y : (x*y) % N
	
	X = U(N)
	
	print_mod_group_info(X, binary_operation, N)	
	
def test_additive_subgroup(N):
	binary_operation = lambda x,y : (x+y) % N
	X = Z(N)
	tools.printf("Z%d:", N)
	print(X)
	for g in X:
		C = subgroup_cyclic(g, binary_operation)
		tools.printf("<%d>", g)
		print(C)
	
def test_multipicative_subgroup(N):
	binary_operation = lambda x,y : (x*y) % N
	X = U(N)
	tools.printf("U%d:", N)
	print(X)
	for g in X:
		C = subgroup_cyclic(g, binary_operation)
		tools.printf("<%d>", g)
		print(C)	
	
def test_modular_multiplicative_inverse_N(a, N):
	"""
	theorem: a has a multiplicative inverse mod N if and only if a, N are relatively prime.
	"""
	