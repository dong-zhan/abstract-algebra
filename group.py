# reference: youtube: Jeff Suzuki:  The Random Professor
# reference: youtube: socratica

# import zd
# import abs_alg.group as group
#
# import importlib
# importlib.reload(group)


def rrr():
	importlib.reload(group)
	
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import util.arr as arr
import util.tools as tools

import random

import math_zd.number as number
from math_zd import modular
import math_zd.perm as perm


# if np,pd,plt is needed for console, copy imp() function to console, then run imp() in console  --> plot.imp() doesn't work.
def imp():
	global np, pd, plt, arr, tools, number, modular, perm
	import numpy as np
	import pandas as pd
	import matplotlib.pyplot as plt
	
	import util.arr as arr
	import util.tools as tools

	import math_zd.number as number
	from math_zd import modular
	import math_zd.perm as perm

def replace_readme_MD():
	tools.replace_line_break_with_br('F:/Python/zd/abs_alg/README.txt', 'F:/Python/zd/abs_alg/README.md')
	
	
def Z(N):
	"""
	Z(5) --> [0, 1, 2, 3, 4]
	Z* is not a group, so, Group Z is always additive Z+
	The Additive Group of Integers Modulo n is the group with domain  {0,1,2,…,n−1}  and with the operation of mod n addition. It is denoted as  Zn.
	Z/nZ is a standard notation for the additive cyclic group with n elements.
	binary_operation = lambda x,y : (x+y) % N
	"""
	return np.arange(0,N,1).tolist()
	
def U(N):
	"""
	this is Zn*
	U(11) --> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	The Multiplicative Group of Integers Modulo n is the group with domain  {k∈Z|1≤k≤n−1 and gcd(n,k)=1} and with the operation of mod n multiplication. It is denoted as Un.
	gcd(x, N) = 1, iff ax + bN = 1
	binary_operation = lambda x,y : (x*y) % N
	"""
	X = []
	for x in np.arange(1,N,1):
		if number.gcd(x, N) == 1:
			X.append(x)
	return X
	
def C(g, N):
	"""
	A group G is cyclic if it is generated by a single element: denote by <a>, or Cn: a cyclic group of n elements
	C(5,11) --> [5, 3, 4, 9, 1]
	The “same” group can be written using multiplicative notation this way: Z7 = {1, a, a², a³, a⁴, a⁵, a⁶}.
	binary_operation = lambda x,y : (x*y) % N
	if additive, then it's Zn too.
	"""
	return modular.modular_pow_no_repeat(g, N)
	
def S(N, toCycles = True):
	"""
	Sn: symmetric group, The group of all permutations
	Sym(M): where M = {1, 2, ..., n}
	binary_operation = lambda x,y : multiply_cycles([x], [y])
	"""
	X = [ i+1 for i in range(N)]
	P = perm.perm(X)
	if toCycles:
		C = arr.array1(len(P))
		idx = 0
		for p in P:
			C[idx] = permutation_to_cycles(p)
			idx += 1
		return C
	return P
	
	
def order_of_element(g, G, e, binary_operation):
	"""
	The order of an element g of a group G is the smallest positive integer n:gⁿ=e
	there is a formula using gcd
	"""
	if g == e:
		return 1
		
	order = 2
	while True:
		g1 = g
		for i in range(order-1):
			g1 = binary_operation(g1, g)
			if g1 == e:
				return order
		#tools.printf("%d·%d = %d\n", order, g, g1)
		order = order + 1
		
def orders_of_subgroups(X):
	"""
	Lagrange's Theorem
	the order of a subgroup is a divisor of the order of a group.
	"""
	return subgroup_orders_generated_by_an_element(X);
	
def subgroup_cyclic(g, binary_operation):
	"""
	subgroup is always a coset
	subgroup notation: H, why use H, because it's after G in alphabet
	construct a subgroup as follows: <g> = {gⁿ | n∈Z}, <g> is called cyclic subgroup generated by g, if <g>=G, then, G is a cyclic group. cyclic groups are all Abelian.
	use the binary_operation of the group, where g belongs.
	"""
	X = [g]
	g1 = g
	while True:
		g1 = binary_operation(g1, g)
		if g1 == g:
			return X
		X.append(g1)

subgroup = subgroup_cyclic


def find_identity(X, binary_operation):
	"""
	X is a set
	find_identity([0, 1, 2], lambda x,y : (x+y) % 3)
	find_identity([0, 1, 2], lambda x,y : (x*y) % 3)
	"""
	for idd in X:
		isIdentity = True
		for x in X:
			if binary_operation(idd, x) != x:
				isIdentity = False
				break
		if isIdentity:
			return idd
	return None
	
def coset_left(a, H, binary_operation):
	"""
	H = subgroup(h, binary_operation)
	cosets are usually not subgroups (some do not even contain the identity). some or all?? 	cosets are not closed, and do not have inverses
	if coset is a group -> normal sub group
	The element a is a representative of the coset aH
	The collection of left cosets is denoted G/H
	Let G be a group and H a subgroup, let a∈G. the set aH = {ah: h∈H} is a left coset of H.
	"""
	X = arr.array1(len(H))
	for ix, xi in enumerate(H):
		X[ix] = binary_operation(a, xi)
	return X

def coset_right(H, a, binary_operation):
	"""
	H = subgroup(h, binary_operation)
	The element a is a representative of the coset Ha
	The set of right cosets is denoted H\G.
	Let G be a group and H a subgroup, let a∈G. the set Ha = {ha: h∈H} is a right coset of H.
	"""
	X = arr.array1(len(H))
	for ix, xi in enumerate(H):
		X[ix] = binary_operation(xi, a)
	return X
	
def subgroup_orders_generated_by_an_element(X):
	"""
	theorem (Lagrange Light)
	the order of a subgroup generated by an element is a divisor of the order of the group
	because <x> = {1, a, a², a³, ...,aᵏ⁻¹}		-- k terms
	"""
	return number.find_all_divisors(len(X))
	
def index(G):
	"""
	the number of cosets is called index of H in G and is written as |G:H| = k, so, d·k = n
	|G| = n, |H| = d  --> d|n, the order of H divides the order of G
	"""
	return len(number.find_all_divisors(len(G))) - 2  

	
def find_inverse(x, X, e, binary_operation):
	"""
	x is an element in set X
	X is a set
	e is identity
	find_inverse(1, [0, 1, 2], 0, lambda x,y : (x+y) % 3)
	"""
	for xi in X:
		if e == binary_operation(x, xi):
			return xi
	return None
	
def find_all_inverses(X, e, binary_operation):
	"""
	see test_find_all_inverses()
	"""
	IX = arr.array1(len(X))
	for ix, x in enumerate(X):
		inv = find_inverse(x, X, e, binary_operation)
		IX[ix] = inv
		#tools.printf("%d -> %d\n", x, inv)
		#if inv != None:
			#print(x)
	return IX
	

def has_Latin_Square_Property(X):
	"""
	every entry in column is different, and every entry in row is different
	"""
	return not arr.hasDuplicatesInRowsAndCols(X)
	
def count_inverse(X, e, binary_operation):
	"""
	X is a set, e is identity
	count_inverse([0, 1, 2, 3], 0, lambda x,y : (x+y)%4)
	"""
	IX = arr.array1(len(X))
	for i, a in enumerate(X):
		IX[i] = 0
		for b in X:
			ab = binary_operation(a, b)
			ba = binary_operation(b, a)
			if ab == e and ba == e:
				#print(a, b, ab, ba, e)
				IX[i] = IX[i]+1
	return IX
	
# TODO: vectorization
def is_associative(X, binary_operation):
	"""
	X is a set
	is_associative([2, 3, 4], lambda x,y : x-y)
	is_associative([2, 3, 4], lambda x,y : x+y)
	"""
	for a in X:
		for b in X:
			for c in X:
				ab = binary_operation(a, b)
				d1 = binary_operation(ab, c)
				bc = binary_operation(b, c)
				d2 = binary_operation(a, bc)
				if d1 != d2:
					#tools.printf("a=%d,b=%d,c=%d, ab=%d, d1=%d, bc=%d, d2=%d\n", a, b, c, ab, d1, bc, d2)
					return False
	return True
	
def is_closed(X, binary_operation):
	"""
	X is a set
	is_closed([0, 1, 2, 3, 4, 5], lambda x,y : (x+y) % 6)
	"""
	for a in X:
		for b in X:
			ab = binary_operation(a, b)
			if not ab in X:
				return False
	return True
	
def is_normal_subgroup(N, G, binary_operation):
	"""
	N is normal if it's invariant under conjugation, that is, the conjugation of an element of N by an element of G is always in N
	is conjugation g⁻¹ng or gng⁻¹?
	N is normal if gNg⁻¹ = N for all g ∈ G
	all subgroups of Abelian groups are normal
	https://math.stackexchange.com/questions/234825/what-exactly-does-conjugation-mean
	"""
	e = find_identity(G, binary_operation)

	for n in N:
		for g in G:
			ig = find_inverse(g, G, e, binary_operation)
			# compute gng⁻¹  (conjugate)
			n1 = binary_operation(g, n)
			n2 = binary_operation(n1, ig)
			if not n2 in N:
				return False
	return True	
	
def generate_additive_mod_N(N):
	"""
	The Additive Group of Integers Modulo n is the group with domain {0,1,2,…,n−1} and with the operation of mod n addition. It is denoted as Zn.
	"""
	return np.arange(0,N,1).tolist()
	
def generate_multipicative_mod_N(N):
	"""
	0 is not in the multiplicative group, since it is not invertible.
	"""
	return np.arange(1,N,1).tolist()

def generate_cyclic_mod_N(a, N):
	return modular.modular_pow_no_repeat(a, N)
	
	
########################################################################################################################
#
#						permutation / cycles
#
########################################################################################################################
	
def next_element_in_cycle(X, x):
	"""
	C = [1,4,3,2]
	next_element_in_cycle(C, 4)
	"""
	if x in X:
		i = X.index(x)
		i = (i+1) % len(X)
		return X[i]
		
def next_element_in_cycle_arrary(X, a):
	"""
	T = [[1,2],[1,3],[1,4]]
	next_element_in_cycle_arrary(T,4)
	"""
	lenX = len(X)
	b = a
	for i in reversed(range(lenX)):
		x = X[i]
		b1 = next_element_in_cycle(x, b)
		if b1 != None:
			b = b1
	return b

def next_element_in_cycle_arrary2(X1, X2, x):
	n = next_element_in_cycle_arrary(X2, x)
	if n == None:
		n = x
	n2 = next_element_in_cycle_arrary(X1, n)
	if n2 != None:
		n = n2
	return n

def permutation_to_cycles(P):
	"""
	P: permutation --> list, all elements must be in it, and must be from 1 to len(P), like the one in example
	C: returned cycles --> list of list
								   [1,2,3,4,5,6]
	example: permutation_to_cycles([3,5,6,4,2,1])
	result: [[1, 3, 6], [2, 5]]
	"""
	# generate indices for P
	R = [i+1 for i in range(len(P))]
	C = []		# cycles list
	
	def scratch_off_by_idx(X, idx):
		c = X[idx]
		X.remove(c)
		return c
		
	while len(R)>0:
		e = scratch_off_by_idx(R, 0)
		n = e
		c = [e]		# c is a single cycle
		
		# form a cycle starting e, result in c
		while True:
			n = P[n-1]
			if n == e:
				break
			R.remove(n)
			c.append(n)
			
		if len(c) > 1:
			#c.sort()
			C.append(c)

	return C		
	
def max_number_in_list_array_2D(C):
	m = C[0][0]
	for c in C:
		m = max(m, max(c))
	return m
	
def cycles_to_permutation(C, maxIndex = None):
	"""
	C = [[1, 3, 6], [2, 5]]
	cycles_to_permutation(C, 6)
	[3, 5, 6, 4, 2, 1]
	"""
	if maxIndex == None:
		maxIndex = max_number_in_list_array_2D(C)
	P = []
	for i in range(maxIndex):
		n = next_element_in_cycle_arrary(C, i+1)
		if n == None:
			n = i+1
		P.append(n)
	return P
	
def invert_permutation(P):
	X = P.copy()		# X = P[:]		# are they the same?
	X.reverse()
	return X
	
def invert_cycles(C, maxIndex):
	P = cycles_to_permutation(C, maxIndex)
	#tools.printf("cycles_to_permutation: %s\n", P)
	P = invert_permutation(P)
	#tools.printf("invert_permutation: %s\n", P)
	return permutation_to_cycles(P)
	
def list_array_to_list(C):
	P = []
	for c in C:
		P = P + c
	return P

def multiply_cycles(C1, C2):
	"""
	a = [1,3]
	b = [1,2, 3]
	c = [1,3]
	C1 = [a,b]
	C2 = [c]
	C = multiply_cycles(C1, C2)
	print(C)
	"""
	# join two lists
	
	R = list(set( list_array_to_list(C1 + C2) ))
	C = []		# cycles list
	
	def scratch_off_by_idx(X, idx):
		c = X[idx]
		X.remove(c)
		return c

	while len(R)>0:
		e = scratch_off_by_idx(R, 0)
		n = e
		c = [e]		# c is a single cycle
		
		# form a cycle starting e, result in c
		while True:
			#n = next_element_in_cycle2(a, b, n)
			n = next_element_in_cycle_arrary2(C1, C2, n)
			if n == None:
				break
			if n == e:
				break
			R.remove(n)
			c.append(n)
			
		if len(c) > 1:
			#c.sort()
			C.append(c)

	return C			
	
	
def multiply_cycles_deprecated(a, b):
	"""
	>>> a=[1,3,5,2]
	>>> b =[2,5,6]
	>>> c=[1,6,3,4]
	>>> group.multiply_cycles(a,b)
	[[1, 3, 5, 6]]	
	>>> group.multiply_cycles(a,c)
	[[1, 6, 5, 2], [3, 4]]
	"""
	T = [a, b]
	# join two lists
	R = list(set(a + b))
	C = []		# cycles list
	
	def scratch_off_by_idx(X, idx):
		c = X[idx]
		X.remove(c)
		return c
		
	while len(R)>0:
		e = scratch_off_by_idx(R, 0)
		n = e
		c = [e]		# c is a single cycle
		
		# form a cycle starting e, result in c
		while True:
			#n = next_element_in_cycle2(a, b, n)
			n = next_element_in_cycle_arrary(T, n)
			if n == None:
				break
			if n == e:
				break
			R.remove(n)
			c.append(n)
			
		if len(c) > 1:
			#c.sort()
			C.append(c)

	return C		
	
		
########################################################################################################################
#
#						Cayley Table
#
########################################################################################################################

def generate_Cayley_table(X, binary_operation):
	"""
	X is a set
	generate_Cayley_table([0, 1, 2, 3], lambda x,y : (x+y) % 4)
	generate_Cayley_table([1, 3, 7, 9], lambda x,y : (x*y) % 10)
	"""
	rows = len(X)
	cols = rows
	N = cols
	T = arr.array2(rows, cols)
	
	for irow, row in enumerate(X):
		for icol, col in enumerate(X):
			#print(irow, icol, row, col, binary_operation(row, col))
			T[irow][icol] = binary_operation(row, col)		
			
	return T
	
def generate_printable_Cayley_table(T, X):
	"""
	T is Cayley table
	X is a set
	add first row and first column into table, the top left should be the binary operation.
	"""
	rows = len(T) + 1
	cols = len(T[0]) + 1
	PT = arr.array2(rows, cols)
	
	for irow, row in enumerate(T):
		for icol, col in enumerate(T):
			PT[irow+1][icol+1] = T[irow][icol]	
			
	for i, ix in enumerate(T):
		PT[0][i+1] = X[i]
		PT[i+1][0] = X[i]
	
	#PT[0][0] = 0
	return PT
			
def print_Cayley_table(T, delimitor = ' '):
	"""
	T is printable Cayley table (Cayley table dimension extended by 1 for extra first row and first column)
	"""
	
	#print(T)
	#return
	
	#pd.set_option('display.max_rows', 500)
	pd.set_option('display.max_columns', len(T))
	pd.set_option('display.width', 1000)	
	
	df = pd.DataFrame(T)
	print(df)

	#df = pd.DataFrame(table, columns = ['a', 'b', 'c', 'd'], index=['row_1', 'row_2'])
	#print(df)

	return
	
	rows = len(T) + 1
	cols = len(T[0]) + 1
	
	for irow, row in enumerate(T):
		for icol, col in enumerate(T):
			t = T[irow][icol]
			if irow == 0 and icol == 0:
				tools.printf("X%c", delimitor)
			else:
				tools.printf("%s%c", t, delimitor)
		tools.printf("\n")
	
########################################################################################################################
#
#						helpers / information
#
########################################################################################################################
	
def print_symmetric_group_info(X, binary_operation):
	T = generate_Cayley_table(X, binary_operation)
	T = np.array(T)
	
	
	print("Cayley table")
	
	PT = generate_printable_Cayley_table(T, X)
	PT = np.array(PT, dtype=object)
	
	# convert empty set in PT into [[]], to avoid warning from pandas "different lengths or shapes"
	if 0:
		empty_element = []
		for irow, row in enumerate(PT):
			for icol, col in enumerate(row):
				if len(col) == 0:
					empty_element.append([irow, icol])
					
		for e in empty_element:
			PT[e[0]][e[1]] = [[]]
		
	print_Cayley_table(PT)

	#return PT
	
def print_mod_group_info(X, binary_operation, N):
	T = generate_Cayley_table(X, binary_operation)
	T = np.array(T)
	
	tools.printf("Mod: %d\nSet: ", N)
	print(X)
	
	print("Cayley table")
	
	PT = generate_printable_Cayley_table(T, X)
	print_Cayley_table(PT)
	
	ia = is_associative(X, binary_operation)
	tools.printf("is_associative = %s\n", ia)
	
	identity = find_identity(X, binary_operation)
	#tools.printf("identity = %s\n", str(identity))
	
	INV = count_inverse(X, identity, binary_operation)
	cols = len(X)
	uniqueIdentity = True
	cnt = INV.count(1)
	if cnt != cols:
		uniqueIdentity = False
	
	tools.printf("unique identity: (%s) %s\n", identity, uniqueIdentity)	
	
	tools.printf("is_closed: %s\n", is_closed(X, binary_operation))
	
	tools.printf("Latin square property: %s\n", has_Latin_Square_Property(T.tolist()))	
	
	
########################################################################################################################
#
#			random testing for correctness, don't remove this, this ensures the software can run correctly.
#
########################################################################################################################	

def random_transpositions(N, cnt):	
	"""
	cnt: number of transpositions
	cnt should be at most N-1, because (a, a) is not a cycle.
	"""
	X = []
	for i in range(cnt):
		n1 = random.randint(1, N)
		n2 = n1
		#while True:
		for j in range(100):
			n2 = random.randint(1, N)
			if n1 != n2 and not [n1,n2] in X and not [n2,n1] in X:
				break
		
		if [n1,n2] in X or [n2,n1] in X:
			print("ERROR")
			print([n1, n2], X)
			print("ERROR")
		
		X.append([n1, n2])
	return X
	
	
def test_multiply_cycles(N, n, show_result = False):
	for i in range(N):
		A = random_transpositions(n, n-1)
		B = random_transpositions(n, n-1)
		C = multiply_cycles(A, B)	 
		if len(C) == 0:
			continue
		IC = invert_cycles(C, n)
		if len(IC) == 0:
			continue
		IIC = invert_cycles(IC, n)
		
		if show_result:
			tools.printf("%s\n%s\n%s\n%s\n%s\n\n", A, B, C, IC, IIC)
		
		if C != IIC:
			print("ERROR")
			print(C, IIC)	
			print("ERROR")
			break

########################################################################################################################
#
#						basic function test
#
########################################################################################################################			
	
	
def test_Carley_table_pow(b, m, N):
	"""
	b: base
	N: modulus
	m: count
	"""
	binary_operation = lambda x,y : (x*y) % N
	X = modular.modular_pow(b, N, m)
	print(X)
	X = generate_Cayley_table(X, binary_operation)
	X = np.array(X)
	print(X)
	
def test_find_all_inverses(b, N):
	binary_operation = lambda x,y : (x*y) % N
	X = modular.modular_pow_no_repeat(b, N)
	identity = find_identity(X, binary_operation)
	IX = find_all_inverses(X, identity, binary_operation)	
	return X, IX


def test_cyclic(a, N):
	"""
	"""
	isCoPrime = number.coprime2(a, N)
	tools.printf("a=%d and N=%d are coprime: %s\n", a, N, isCoPrime)
	tools.printf("so, a=%d has modular multiplicative inverse: %s\n", a, isCoPrime)

	tools.printf("cyclic group <%d> ", a)
	binary_operation = lambda x,y : (x*y) % N
	
	X = generate_cyclic_mod_N(a, N)
	
	print_mod_group_info(X, binary_operation, N)
	
def test_U(N):
	"""
	Group: Un
	"""
	tools.printf("Multiplicative Group of Integers Modulo %d (U%d)\n", N, N)

	binary_operation = lambda x,y : (x*y) % N
	
	X = U(N)
	
	print_mod_group_info(X, binary_operation, N)	
	
def test_Sn(N):
	G = S(N)
	tools.printf("S(%d): %s\n", N, G)
	binary_operation = lambda x,y : multiply_cycles(x, y)
	
	print_symmetric_group_info(G, binary_operation)	
	
	
def test_additive_subgroup(N):
	"""
	Group: Zn+
	"""
	binary_operation = lambda x,y : (x+y) % N
	X = Z(N)
	tools.printf("Z%d:", N)
	print(X)
	for g in X:
		C = subgroup_cyclic(g, binary_operation)
		tools.printf("<%d>", g)
		print(C)
	
	

			
	
def test_Un(N):
	"""
	Group: U(n)
	"""
	tools.printf("the order of the group is (%d-1) = %d\n", N, N-1)
	
	D = number.find_all_divisors(N-1)
	tools.printf("the possible orders of the subgroups are: ");
	print(D)

	binary_operation = lambda x,y : (x*y) % N
	X = U(N)
	tools.printf("U%d:", N)
	print(X)
	for g in X:
		C = subgroup_cyclic(g, binary_operation)
		tools.printf("<%d>", g)
		print(C)	
		

def test_additive_coset(N, h, G):
	"""
	Group: Z12+
	test_additive_coset(12, 3, [1,2])
	"""
	binary_operation = lambda x,y : (x+y) % N
	X = Z(N)
	tools.printf("Z%d:", N)
	print(X)
	
	H = subgroup_cyclic(h, binary_operation)
	tools.printf("subgroup generated by <%d>:", h)
	print(H)
	
	for g in G:
		C = coset_left(g, H, binary_operation)
		tools.printf("coset generated by %d·<%d>:", g, h)
		print(C)
	
	
def test_multiplicative_coset(N, h, G):
	"""
	Group: U(N)
	test_multiplicative_coset(13,3,[2,4,7])
	"""
	binary_operation = lambda x,y : (x*y) % N
	X = U(N)
	tools.printf("U%d:", N)
	print(X)
	
	H = subgroup_cyclic(h, binary_operation)
	tools.printf("subgroup generated by <%d>:", h)
	print(H)
	
	for g in G:
		C = coset_left(g, H, binary_operation)
		tools.printf("coset generated by %d·<%d>:", g, h)
		print(C)
	
def test_quotient_group():
	N = 11
	binary_operation = lambda x,y : (x*y) % N

	tools.printf("U11")
	Un = U(N)
	print(Un)
	
	print("cosets of order 5")

	h = 10
	H = subgroup_cyclic(h, binary_operation)
	tools.printf("<%d>", h)
	print(H)

	hs = [2,3,4,5]
	for h in hs:
		aH = coset_left(h, H, binary_operation)
		tools.printf("<%d>", h)
		print(aH)
		
def test_orbit():
	N = 31
	binary_operation = lambda x,y : (x*y) % N
	
	U31 = U(N)
	
	h = 2
	H = subgroup_cyclic(h, binary_operation)
	tools.printf("<%d>", h)
	print(H)

	S = []
	hs = [3,5,7,11,15]
	S.append(hs)
	for h in hs:
		aH = coset_left(h, H, binary_operation)
		S.append(aH)
		#tools.printf("<%d>", h)
		#print(aH)
		
	print(np.array(S))
	
	

	
	
	
def find_subgroup(order):
	pass
	
